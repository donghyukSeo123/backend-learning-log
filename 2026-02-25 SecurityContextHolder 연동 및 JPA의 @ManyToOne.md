## 📅 2026-02-25 | 데이터 영속화 고도화: SecurityContextHolder와 Entity 매핑

### ✅ 오늘 진행한 작업 (What I Did)

#### 1. SecurityContextHolder 연동 및 유저 식별 로직 구현
* **전역 보안 컨텍스트 활용**: `SecurityContextHolder`를 통해 인증된 사용자의 정보를 스레드 단위로 관리.
* **요청별 식별**: 컨트롤러 및 서비스 레이어에서 현재 요청을 보낸 유저가 누구인지 식별하는 로직 완성.

#### 2. 연관관계 기반 데이터 저장 (User ↔ Project)
* **데이터 귀속**: 생성된 프로젝트가 로그인한 사용자(인사장님)에게 귀속되도록 서비스 레이어 구축.
* **JPA 매핑**: `Project` 엔티티와 `User` 엔티티 간의 `@ManyToOne` 관계 설정을 통해 DB 외래 키(FK) 할당 확인.

#### 3. 정적 팩토리 메서드(`from`) 패턴 적용
* **객체 생성 의도 명확화**: `new` 키워드 대신 `ProjectResponseDto.from(project)` 형태의 static 메서드 사용.
* **가독성 향상**: 클래스 수준에서 객체 변환의 의미를 명확히 전달하도록 구조 개선.

#### 4. JPA 필드 초기화 및 @Builder 설정
* **기본값 보존**: DB의 `DEFAULT` 설정이 무시되는 현상을 방지하기 위해 `@Builder.Default` 적용.
* **데이터 안정성**: `status` 필드 등에 초기값을 강제로 할당하여 프론트엔드 데이터 누락 시에도 시스템 정책 유지.

---

### 💡 새롭게 알게 된 점 (Learned)

* **🛡️ SecurityContextHolder의 동작 원리**: `ThreadLocal`을 기반으로 동작하여 각 요청 스레드마다 독립적인 보안 장부를 관리함. `@AuthenticationPrincipal`로 이를 간편하게 호출하는 원리를 파악함.
* **🏗️ 정적 메서드 vs 생성자**: `static` 메서드는 "어디로부터(from)" 생성되었는지 의도를 명확히 표현할 수 있어 생성자보다 가독성 면에서 유리함.
* **⚠️ JPA Null 저장 이슈**: 엔티티 필드가 `null`이면 DB의 기본값이 무시되고 `null`이 저장되므로, 자바 단에서 초기값을 설정하는 것이 안전하다는 점을 배움.
* **🔗 데이터 귀속의 중요성**: FK 매핑을 통해 소유권을 확립해야 향후 '내 프로젝트 목록 조회'와 같은 개인화된 비즈니스 로직이 가능해짐.

---

### 🧠 오늘의 핵심 개념

#### 🛡️ SecurityContextHolder (보안 컨텍스트 저장소)
> 현재 실행 중인 스레드 내에서 인증된 사용자 정보를 보관하고 공유함. 인증 필터에서 검증된 정보를 장부(Context)에 등록하여 앱 전역에서 유저 정보를 꺼내 쓸 수 있게 함.

#### 🏗️ 정적 팩토리 메서드 (from 메서드)
> 클래스 내부에 `static`으로 정의된 객체 생성 전용 메서드. `Dto.from(entity)`와 같이 명명하여 객체 변환의 의미를 코드에 담음.

#### ⚠️ JPA @Builder.Default
> 빌더 패턴 사용 시 특정 필드에 자바 단의 기본값을 강제로 할당하기 위함. `status` 필드를 "Y"로 초기화하여 데이터 무결성을 보장함.

---

### 📌 요약 및 회고
**컨텐츠메이커스튜디오**는 이제 로그인한 사용자의 정보를 자유롭게 활용하고, 프로젝트 데이터가 각 사용자에게 정확히 귀속되는 안정적인 백엔드 파이프라인을 갖추게 됨. 데이터 소유권 관리가 가능해진 만큼, 이후 사용자별 맞춤형 기능 구현의 기틀이 마련됨.
